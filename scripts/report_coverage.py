#! /usr/bin/env python3

"""
Generate a coverage report from an XML report generated by coverage.py and
diff-cover. This report is intended to be used to make a PR comment with the
coverage summary and the diff coverage.
"""

import argparse
import re
import subprocess
import sys
import xml.etree.ElementTree as ET
from pathlib import Path


def parse_coverage_xml(xml_path: str) -> tuple[list[dict], dict]:
    """
    Parse the XML report generated by coverage.py and return the coverage data
    for each file and the total coverage.
    """

    tree = ET.parse(xml_path)
    root = tree.getroot()

    coverage_data = []
    total_lines = 0
    total_covered_lines = 0
    total_branches = 0
    total_covered_branches = 0

    for class_elem in root.findall(".//class"):
        filename = class_elem.get("filename")
        line_rate = float(class_elem.get("line-rate"))
        branch_rate = float(class_elem.get("branch-rate"))

        lines = class_elem.find("lines")
        file_total_lines = len(lines.findall("line"))
        file_covered_lines = len(
            [line for line in lines.findall("line") if int(line.get("hits")) > 0]
        )

        file_total_branches = 0
        file_covered_branches = 0
        for line in lines.findall("line"):
            condition_coverage = line.get("condition-coverage")
            if condition_coverage:
                match = re.search(r"(\d+)%\s*\((\d+)/(\d+)\)", condition_coverage)
                if match:
                    covered, total = map(int, match.group(2, 3))
                    file_total_branches += total
                    file_covered_branches += covered

        coverage_data.append(
            {
                "filename": filename,
                "line_rate": line_rate,
                "branch_rate": branch_rate,
                "total_lines": file_total_lines,
                "covered_lines": file_covered_lines,
                "total_branches": file_total_branches,
                "covered_branches": file_covered_branches,
            }
        )

        total_lines += file_total_lines
        total_covered_lines += file_covered_lines
        total_branches += file_total_branches
        total_covered_branches += file_covered_branches

    total_coverage = {
        "line_rate": total_covered_lines / total_lines if total_lines > 0 else 0,
        "branch_rate": total_covered_branches / total_branches if total_branches > 0 else 0,
        "total_lines": total_lines,
        "covered_lines": total_covered_lines,
        "total_branches": total_branches,
        "covered_branches": total_covered_branches,
    }

    return coverage_data, total_coverage


def generate_coverage_summary(coverage_data, total_coverage):
    summary = f"""# Coverage Summary

## Total Project Coverage

- **Line Coverage**: {total_coverage['line_rate']:.2%} ({total_coverage['covered_lines']}/{total_coverage['total_lines']})
- **Branch Coverage**: {total_coverage['branch_rate']:.2%} ({total_coverage['covered_branches']}/{total_coverage['total_branches']})

## Coverage by File

| File | Line Coverage | Branch Coverage | Lines (Covered/Total) | Branches (Covered/Total) |
|------|---------------|-----------------|-----------------------|--------------------------|
"""

    file_lines = []

    for data in coverage_data:
        line_coverage = f"{data['line_rate']:.2%}"
        branch_coverage = f"{data['branch_rate']:.2%}"
        lines = f"{data['covered_lines']}/{data['total_lines']}"
        branches = f"{data['covered_branches']}/{data['total_branches']}"
        file_lines.append(
            f"| `{data['filename']}` | {line_coverage} | {branch_coverage} | {lines} | {branches} |"
        )

    summary += "\n".join(file_lines)

    return summary


def run_diff_cover(xml_path: str, base_branch: str) -> str:
    """
    Run diff-cover with the given base branch and return the markdown report.
    """

    report_path = Path(".diff_cover_md_report.md")

    result = subprocess.run(
        [
            "diff-cover",
            xml_path,
            f"--compare-branch={base_branch}",
            f"--markdown-report={report_path}",
        ],
        # The output is captured to avoid printing diff-cover's logs to stdout.
        capture_output=True,
    )

    if result.returncode != 0:
        print("Error running diff-cover:", result.stderr, file=sys.stderr)
        sys.exit(1)

    report_data = report_path.read_text()
    report_path.unlink()

    return report_data


def parse_diff_cover_output(output: str) -> tuple[str, str]:
    """
    Read the markdown report and split it into a details and a summary. This is
    useful to show the summary in the PR comment and the details in a
    collapsible section.

    :return: A tuple with the summary and the details.
    """

    summary_index = output.find("## Summary")
    if summary_index == -1:
        # If there is no summary, there were no diffs that had to be covered,
        # so the entire report is the summary.
        return output, ""

    details_index = output.find("## ", summary_index + 1)
    if details_index == -1:
        # If there are no other sections after the summary, once again the
        # entire report is the summary.
        return output, ""

    summary = output[:details_index]
    details = output[details_index:]

    return summary, details


def main():
    parser = argparse.ArgumentParser(
        description="Generate a coverage report from XML and diff-cover."
    )
    parser.add_argument("xml_path", help="Path to the coverage XML file")
    parser.add_argument("base_branch", help="Base branch to compare for diff coverage")
    parser.add_argument(
        "--output", help="Path to output markdown file. If not provided, prints to stdout."
    )
    args = parser.parse_args()

    coverage_data, total_coverage = parse_coverage_xml(args.xml_path)
    coverage_summary = generate_coverage_summary(coverage_data, total_coverage)

    diff_cover_data = run_diff_cover(args.xml_path, args.base_branch)
    diff_summary, diff_details = parse_diff_cover_output(diff_cover_data)

    final_report = f"{coverage_summary}\n\n{diff_summary}\n\n"
    if len(diff_details) > 0:
        final_report += f"""
<details>
<summary>Diff Coverage Details</summary>


{diff_details}
</details>
"""

    if args.output:
        with open(args.output, "w") as f:
            f.write(final_report)
        print(f"Coverage report generated: {args.output}")
    else:
        print(final_report)


if __name__ == "__main__":
    main()
